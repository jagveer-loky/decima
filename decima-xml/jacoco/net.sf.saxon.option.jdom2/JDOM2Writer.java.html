<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDOM2Writer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Decima Framework XML Support</a> &gt; <a href="index.source.html" class="el_package">net.sf.saxon.option.jdom2</a> &gt; <span class="el_source">JDOM2Writer.java</span></div><h1>JDOM2Writer.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2015 Saxonica Limited.
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// This Source Code Form is &quot;Incompatible With Secondary Licenses&quot;, as defined by the Mozilla Public License, v. 2.0.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package net.sf.saxon.option.jdom2;

import net.sf.saxon.event.PipelineConfiguration;
import net.sf.saxon.expr.parser.Location;
import net.sf.saxon.lib.NamespaceConstant;
import net.sf.saxon.om.NamespaceBinding;
import net.sf.saxon.om.NodeInfo;
import net.sf.saxon.om.NodeName;
import net.sf.saxon.trans.XPathException;
import net.sf.saxon.tree.util.FastStringBuffer;
import net.sf.saxon.type.SchemaType;
import net.sf.saxon.type.SimpleType;
import net.sf.saxon.value.Whitespace;
import org.jdom2.*;

import java.util.Stack;

/**
 * JDOMWriter is a Receiver that constructs a JDOM2 document from the stream of events
 */

public class JDOM2Writer extends net.sf.saxon.event.Builder {

    private Document document;
<span class="nc" id="L32">    private Stack&lt;Parent&gt; ancestors = new Stack&lt;Parent&gt;();</span>
<span class="nc" id="L33">    private boolean implicitDocumentNode = false;</span>
<span class="nc" id="L34">    private FastStringBuffer textBuffer = new FastStringBuffer(FastStringBuffer.C256);</span>

    /**
     * Create a JDOM2Writer using the default node factory
     *
     * @param pipe information about the Saxon pipeline
     */

    public JDOM2Writer(PipelineConfiguration pipe) {
<span class="nc" id="L43">        super(pipe);</span>
<span class="nc" id="L44">    }</span>

    /**
     * Notify an unparsed entity URI.
     *
     * @param name     The name of the unparsed entity
     * @param systemID The system identifier of the unparsed entity
     * @param publicID The public identifier of the unparsed entity
     */

    public void setUnparsedEntity(String name, String systemID, String publicID) throws XPathException {
        // no-op
<span class="nc" id="L56">    }</span>

    /**
     * Start of the document.
     */

    public void open() {
<span class="nc" id="L63">    }</span>

    /**
     * End of the document.
     */

    public void close() {
<span class="nc" id="L70">    }</span>

    /**
     * Start of a document node.
     */

    public void startDocument(int properties) throws XPathException {
<span class="nc" id="L77">        document = new Document();</span>
<span class="nc" id="L78">        document.setBaseURI(systemId);</span>
<span class="nc" id="L79">        ancestors.push(document);</span>
<span class="nc" id="L80">        textBuffer.setLength(0);</span>
<span class="nc" id="L81">    }</span>

    /**
     * Notify the end of a document node
     */

    public void endDocument() throws XPathException {
<span class="nc" id="L88">        ancestors.pop();</span>
<span class="nc" id="L89">    }</span>

    /**
     * Start of an element.
     */

    public void startElement(NodeName nameCode, SchemaType typeCode, Location location, int properties) throws XPathException {
<span class="nc" id="L96">        flush();</span>
<span class="nc" id="L97">        String local = nameCode.getLocalPart();</span>
<span class="nc" id="L98">        String uri = nameCode.getURI();</span>
<span class="nc" id="L99">        String prefix = nameCode.getPrefix();</span>
        Element element;
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (ancestors.isEmpty()) {</span>
<span class="nc" id="L102">            startDocument(0);</span>
<span class="nc" id="L103">            implicitDocumentNode = true;</span>
        }
<span class="nc" id="L105">        element = new Element(local, prefix, uri);</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (ancestors.size() == 1) {</span>
<span class="nc" id="L107">            document.setRootElement(element);</span>
        } else {
<span class="nc" id="L109">            ancestors.peek().addContent(element);</span>
        }
<span class="nc" id="L111">        ancestors.push(element);</span>
<span class="nc" id="L112">    }</span>

    public void namespace(NamespaceBinding namespaceBinding, int properties) throws XPathException {
<span class="nc" id="L115">        String prefix = namespaceBinding.getPrefix();</span>
<span class="nc" id="L116">        String uri = namespaceBinding.getURI();</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (uri.isEmpty() &amp;&amp; prefix.length() != 0) {</span>
            // ignore XML 1.1 namespace undeclarations because JDOM can't handle them
<span class="nc" id="L119">            return;</span>
        }
<span class="nc bnc" id="L121" title="All 2 branches missed.">        Namespace ns = prefix.isEmpty() ?</span>
<span class="nc" id="L122">            Namespace.getNamespace(uri) :</span>
<span class="nc" id="L123">            Namespace.getNamespace(prefix, uri);</span>
<span class="nc" id="L124">        ((Element) ancestors.peek()).addNamespaceDeclaration(ns);</span>
<span class="nc" id="L125">    }</span>

    public void attribute(NodeName nameCode, SimpleType typeCode, CharSequence value, Location locationId, int properties)
            throws XPathException {
<span class="nc" id="L129">        String local = nameCode.getLocalPart();</span>
<span class="nc" id="L130">        String uri = nameCode.getURI();</span>
<span class="nc" id="L131">        String prefix = nameCode.getPrefix();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        Namespace ns = prefix.isEmpty() ?</span>
<span class="nc" id="L133">            Namespace.getNamespace(uri) :</span>
<span class="nc" id="L134">            Namespace.getNamespace(prefix, uri);</span>
<span class="nc" id="L135">        Attribute att = new Attribute(local, value.toString(), ns);</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">        if (uri.equals(NamespaceConstant.XML) &amp;&amp; local.equals(&quot;id&quot;)) {</span>
<span class="nc" id="L137">            value = Whitespace.trim(value);</span>
<span class="nc" id="L138">            att.setAttributeType(AttributeType.ID);</span>
        }
<span class="nc" id="L140">        ((Element) ancestors.peek()).getAttributes().add(att);</span>
<span class="nc" id="L141">    }</span>

    public void startContent() throws XPathException {
<span class="nc" id="L144">        flush();</span>
<span class="nc" id="L145">    }</span>

    /**
     * End of an element.
     */

    public void endElement() throws XPathException {
<span class="nc" id="L152">        flush();</span>
<span class="nc" id="L153">        ancestors.pop();</span>
<span class="nc" id="L154">        Object parent = ancestors.peek();</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">        if (parent == document &amp;&amp; implicitDocumentNode) {</span>
<span class="nc" id="L156">            endDocument();</span>
        }
<span class="nc" id="L158">    }</span>

    /**
     * Character data.
     */

    public void characters(CharSequence chars, Location locationId, int properties) throws XPathException {
<span class="nc" id="L165">        textBuffer.append(chars);</span>
<span class="nc" id="L166">    }</span>

    private void flush() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (textBuffer.length() != 0) {</span>
<span class="nc" id="L170">            Text text = new Text(textBuffer.toString());</span>
<span class="nc" id="L171">            ancestors.peek().addContent(text);</span>
<span class="nc" id="L172">            textBuffer.setLength(0);</span>
        }
<span class="nc" id="L174">    }</span>


    /**
     * Handle a processing instruction.
     */

    public void processingInstruction(String target, CharSequence data, Location locationId, int properties)
            throws XPathException {
<span class="nc" id="L183">        flush();</span>
<span class="nc" id="L184">        ProcessingInstruction pi = new ProcessingInstruction(target, data.toString());</span>
<span class="nc" id="L185">        ancestors.peek().addContent(pi);</span>
<span class="nc" id="L186">    }</span>

    /**
     * Handle a comment.
     */

    public void comment(CharSequence chars, Location locationId, int properties) throws XPathException {
<span class="nc" id="L193">        flush();</span>
<span class="nc" id="L194">        Comment comment = new Comment(chars.toString());</span>
<span class="nc" id="L195">        ancestors.peek().addContent(comment);</span>
<span class="nc" id="L196">    }</span>

    /**
     * Ask whether this Receiver (or the downstream pipeline) makes any use of the type annotations
     * supplied on element and attribute events
     *
     * @return true if the Receiver makes any use of this information. If false, the caller
     *         may supply untyped nodes instead of supplying the type annotation
     */

    public boolean usesTypeAnnotations() {
<span class="nc" id="L207">        return false;</span>
    }

    /**
     * Get the constructed document node
     *
     * @return the document node of the constructed XOM tree
     */

    public Document getDocument() {
<span class="nc" id="L217">        return document;</span>
    }

    /**
     * Get the current root node.
     *
     * @return a Saxon wrapper around the constructed XOM document node
     */

    public NodeInfo getCurrentRoot() {
<span class="nc" id="L227">        return new JDOM2DocumentWrapper(document, config).getRootNode();</span>
    }
}


// Original Code is Copyright (c) 2009 Saxonica Limited. All rights reserved.
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>