<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JDOM2NodeWrapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Decima Framework XML Support</a> &gt; <a href="index.source.html" class="el_package">net.sf.saxon.option.jdom2</a> &gt; <span class="el_source">JDOM2NodeWrapper.java</span></div><h1>JDOM2NodeWrapper.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2015 Saxonica Limited.
// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
// If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
// This Source Code Form is &quot;Incompatible With Secondary Licenses&quot;, as defined by the Mozilla Public License, v. 2.0.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package net.sf.saxon.option.jdom2;

import net.sf.saxon.event.Receiver;
import net.sf.saxon.expr.parser.Location;
import net.sf.saxon.lib.NamespaceConstant;
import net.sf.saxon.om.*;
import net.sf.saxon.pattern.AnyNodeTest;
import net.sf.saxon.pattern.NodeKindTest;
import net.sf.saxon.pattern.NodeTest;
import net.sf.saxon.trans.XPathException;
import net.sf.saxon.tree.iter.*;
import net.sf.saxon.tree.util.FastStringBuffer;
import net.sf.saxon.tree.util.Navigator;
import net.sf.saxon.tree.wrapper.AbstractNodeWrapper;
import net.sf.saxon.tree.wrapper.SiblingCountingNode;
import net.sf.saxon.type.Type;
import net.sf.saxon.type.UType;
import org.jdom2.*;
import org.jdom2.filter.ElementFilter;
import org.jdom2.located.Located;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

/**
 * A node in the XML parse tree representing an XML element, character content, or attribute.&lt;P&gt;
 * This is the implementation of the NodeInfo interface used as a wrapper for JDOM2 nodes.
 *
 * @author Michael H. Kay
 */

public class JDOM2NodeWrapper extends AbstractNodeWrapper implements SiblingCountingNode {

    protected Object node;          // the JDOM node to which this XPath node is mapped; or a List of
    // adjacent text nodes
    protected short nodeKind;
    private JDOM2NodeWrapper parent;     // null means unknown
    protected int index;            // -1 means unknown

    /**
     * This constructor is protected: nodes should be created using the wrap
     * factory method on the DocumentWrapper class
     *
     * @param node   The JDOM node to be wrapped
     * @param parent The NodeWrapper that wraps the parent of this node
     * @param index  Position of this node among its siblings
     */
<span class="fc" id="L57">    protected JDOM2NodeWrapper(Object node, JDOM2NodeWrapper parent, int index) {</span>
<span class="fc" id="L58">        this.node = node;</span>
<span class="fc" id="L59">        this.parent = parent;</span>
<span class="fc" id="L60">        this.index = index;</span>
<span class="fc" id="L61">    }</span>

    /**
     * Factory method to wrap a JDOM node with a wrapper that implements the Saxon
     * NodeInfo interface.
     *
     * @param node       The JDOM node
     * @param docWrapper The wrapper for the Document containing this node
     * @return The new wrapper for the supplied node
     */
    protected static JDOM2NodeWrapper makeWrapper(Object node, JDOM2DocumentWrapper docWrapper) {
<span class="fc" id="L72">        return makeWrapper(node, docWrapper, null, -1);</span>
    }

    /**
     * Factory method to wrap a JDOM node with a wrapper that implements the Saxon
     * NodeInfo interface.
     *
     * @param node       The JDOM node
     * @param docWrapper The wrapper for the Document containing this node
     * @param parent     The wrapper for the parent of the JDOM node
     * @param index      The position of this node relative to its siblings
     * @return The new wrapper for the supplied node
     */

    protected static JDOM2NodeWrapper makeWrapper(Object node, JDOM2DocumentWrapper docWrapper,
                                           JDOM2NodeWrapper parent, int index) {
        JDOM2NodeWrapper wrapper;
<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (node instanceof Document) {</span>
<span class="fc" id="L90">            wrapper = (JDOM2NodeWrapper)docWrapper.getRootNode();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">            if (wrapper == null) {</span>
<span class="fc" id="L92">                wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="fc" id="L93">                wrapper.nodeKind = Type.DOCUMENT;</span>
            }
<span class="fc bfc" id="L95" title="All 2 branches covered.">        } else if (node instanceof Element) {</span>
<span class="fc" id="L96">            wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="fc" id="L97">            wrapper.nodeKind = Type.ELEMENT;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        } else if (node instanceof Attribute) {</span>
<span class="fc" id="L99">            wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="fc" id="L100">            wrapper.nodeKind = Type.ATTRIBUTE;</span>
<span class="pc bpc" id="L101" title="2 of 4 branches missed.">        } else if (node instanceof String || node instanceof Text) {</span>
<span class="fc" id="L102">            wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="fc" id="L103">            wrapper.nodeKind = Type.TEXT;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        } else if (node instanceof Comment) {</span>
<span class="nc" id="L105">            wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="nc" id="L106">            wrapper.nodeKind = Type.COMMENT;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        } else if (node instanceof ProcessingInstruction) {</span>
<span class="nc" id="L108">            wrapper = new JDOM2NodeWrapper(node, parent, index);</span>
<span class="nc" id="L109">            wrapper.nodeKind = Type.PROCESSING_INSTRUCTION;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        } else if (node instanceof Namespace) {</span>
<span class="nc" id="L111">            throw new IllegalArgumentException(&quot;Cannot wrap JDOM namespace objects&quot;);</span>
        } else {
<span class="nc" id="L113">            throw new IllegalArgumentException(&quot;Bad node type in JDOM! &quot; + node.getClass() + &quot; instance &quot; + node.toString());</span>
        }
<span class="fc" id="L115">        wrapper.treeInfo = docWrapper;</span>
<span class="fc" id="L116">        return wrapper;</span>
    }

    /**
     * Get the underlying JDOM node, to implement the VirtualNode interface
     */

    public Object getUnderlyingNode() {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">        if (node instanceof List) {</span>
<span class="nc" id="L125">            return ((List) node).get(0);</span>
        } else {
<span class="fc" id="L127">            return node;</span>
        }
    }

    public JDOM2DocumentWrapper getTreeInfo() {
<span class="fc" id="L132">        return (JDOM2DocumentWrapper)treeInfo;</span>
    }

    /**
     * Return the type of node.
     *
     * @return one of the values Node.ELEMENT, Node.TEXT, Node.ATTRIBUTE, etc.
     */

    public int getNodeKind() {
<span class="fc" id="L142">        return nodeKind;</span>
    }

    /**
     * Determine the relative position of this node and another node, in document order.
     * The other node will always be in the same document.
     *
     * @param other The other node, whose position is to be compared with this node
     * @return -1 if this node precedes the other node, +1 if it follows the other
     *         node, or 0 if they are the same node. (In this case, isSameNode() will always
     *         return true, and the two nodes will produce the same result for generateId())
     */

    public int compareOrder(NodeInfo other) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (other instanceof SiblingCountingNode) {</span>
<span class="nc" id="L157">            return Navigator.compareOrder(this, (SiblingCountingNode) other);</span>
        } else {
            // it must be a namespace node
<span class="nc" id="L160">            return -other.compareOrder(this);</span>
        }
    }

    /**
     * Get the value of the item as a CharSequence. This is in some cases more efficient than
     * the version of the method that returns a String.
     */

    public CharSequence getStringValueCS() {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (node instanceof List) {</span>
            // This wrapper is mapped to a list of adjacent text nodes
<span class="nc" id="L172">            List nodes = (List) node;</span>
<span class="nc" id="L173">            FastStringBuffer fsb = new FastStringBuffer(FastStringBuffer.C64);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            for (Object node1 : nodes) {</span>
<span class="nc" id="L175">                Text o = (Text) node1;</span>
<span class="nc" id="L176">                fsb.append(getStringValue(o));</span>
<span class="nc" id="L177">            }</span>
<span class="nc" id="L178">            return fsb;</span>
        } else {
<span class="fc" id="L180">            return getStringValue(node);</span>
        }
    }

    @Override
    public int getLineNumber() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (node instanceof Located) {</span>
<span class="nc" id="L187">            return ((Located) node).getLine();</span>
        } else {
<span class="nc" id="L189">            return -1;</span>
        }
    }

    @Override
    public int getColumnNumber() {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (node instanceof Located) {</span>
<span class="nc" id="L196">            return ((Located) node).getColumn();</span>
        } else {
<span class="nc" id="L198">            return -1;</span>
        }
    }


    /**
     * Supporting method to get the string value of a node
     *
     * @param node the JDOM node
     * @return the XPath string value of the node
     */

    private static String getStringValue(Object node) {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        if (node instanceof Document) {</span>
<span class="nc" id="L212">            List children1 = ((Document) node).getContent();</span>
<span class="nc" id="L213">            FastStringBuffer sb1 = new FastStringBuffer(FastStringBuffer.C256);</span>
<span class="nc" id="L214">            expandStringValue(children1, sb1);</span>
<span class="nc" id="L215">            return sb1.toString();</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        } else if (node instanceof Element) {</span>
<span class="nc" id="L217">            return ((Element) node).getValue();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        } else if (node instanceof Attribute) {</span>
<span class="fc" id="L219">            return ((Attribute) node).getValue();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        } else if (node instanceof Text) {</span>
<span class="nc" id="L221">            return ((Text) node).getText();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        } else if (node instanceof String) {</span>
<span class="nc" id="L223">            return (String) node;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (node instanceof Comment) {</span>
<span class="nc" id="L225">            return ((Comment) node).getText();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        } else if (node instanceof ProcessingInstruction) {</span>
<span class="nc" id="L227">            return ((ProcessingInstruction) node).getData();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        } else if (node instanceof Namespace) {</span>
<span class="nc" id="L229">            return ((Namespace) node).getURI();</span>
        } else {
<span class="nc" id="L231">            return &quot;&quot;;</span>
        }
    }

    /**
     * Get the string values of all the nodes in a list, concatenating the values into
     * a supplied string buffer
     *
     * @param list the list containing the nodes
     * @param sb   the StringBuffer to contain the result
     */
    private static void expandStringValue(List list, FastStringBuffer sb) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (Object obj : list) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (obj instanceof Element) {</span>
<span class="nc" id="L245">                sb.append(((Element) obj).getValue());</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            } else if (obj instanceof Text) {</span>
<span class="nc" id="L247">                sb.append(((Text) obj).getText());</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            } else if (obj instanceof EntityRef) {</span>
<span class="nc" id="L249">                throw new IllegalStateException(&quot;Unexpanded entity in JDOM tree&quot;);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            } else if (obj instanceof DocType) {</span>
                // do nothing: can happen in JDOM beta 10
            } else {
<span class="nc" id="L253">                throw new AssertionError(&quot;Unknown JDOM node type&quot;);</span>
            }
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">    }</span>

    /**
     * Get the local part of the name of this node. This is the name after the &quot;:&quot; if any.
     *
     * @return the local part of the name. For an unnamed node, returns &quot;&quot;.
     */

    public String getLocalPart() {
<span class="pc bpc" id="L265" title="4 of 6 branches missed.">        switch (nodeKind) {</span>
            case Type.ELEMENT:
<span class="fc" id="L267">                return ((Element) node).getName();</span>
            case Type.ATTRIBUTE:
<span class="fc" id="L269">                return ((Attribute) node).getName();</span>
            case Type.TEXT:
            case Type.COMMENT:
            case Type.DOCUMENT:
<span class="nc" id="L273">                return &quot;&quot;;</span>
            case Type.PROCESSING_INSTRUCTION:
<span class="nc" id="L275">                return ((ProcessingInstruction) node).getTarget();</span>
            case Type.NAMESPACE:
<span class="nc" id="L277">                return ((Namespace) node).getPrefix();</span>
            default:
<span class="nc" id="L279">                return null;</span>
        }
    }

    /**
     * Get the prefix part of the name of this node. This is the name before the &quot;:&quot; if any.
     * (Note, this method isn't required as part of the NodeInfo interface.)
     *
     * @return the prefix part of the name. For an unnamed node, return an empty string.
     */

    public String getPrefix() {
<span class="nc bnc" id="L291" title="All 3 branches missed.">        switch (nodeKind) {</span>
            case Type.ELEMENT:
<span class="nc" id="L293">                return ((Element) node).getNamespacePrefix();</span>
            case Type.ATTRIBUTE:
<span class="nc" id="L295">                return ((Attribute) node).getNamespacePrefix();</span>
            default:
<span class="nc" id="L297">                return &quot;&quot;;</span>
        }
    }

    /**
     * Get the URI part of the name of this node. This is the URI corresponding to the
     * prefix, or the URI of the default namespace if appropriate.
     *
     * @return The URI of the namespace of this node. For an unnamed node,
     *         or for a node with an empty prefix, return an empty
     *         string.
     */

    public String getURI() {
<span class="pc bpc" id="L311" title="1 of 3 branches missed.">        switch (nodeKind) {</span>
            case Type.ELEMENT:
<span class="fc" id="L313">                return ((Element) node).getNamespaceURI();</span>
            case Type.ATTRIBUTE:
<span class="fc" id="L315">                return ((Attribute) node).getNamespaceURI();</span>
            default:
<span class="nc" id="L317">                return &quot;&quot;;</span>
        }
    }

    /**
     * Get the display name of this node. For elements and attributes this is [prefix:]localname.
     * For unnamed nodes, it is an empty string.
     *
     * @return The display name of this node.
     *         For a node with no name, return an empty string.
     */

    public String getDisplayName() {
<span class="nc bnc" id="L330" title="All 4 branches missed.">        switch (nodeKind) {</span>
            case Type.ELEMENT:
<span class="nc" id="L332">                return ((Element) node).getQualifiedName();</span>
            case Type.ATTRIBUTE:
<span class="nc" id="L334">                return ((Attribute) node).getQualifiedName();</span>
            case Type.PROCESSING_INSTRUCTION:
            case Type.NAMESPACE:
<span class="nc" id="L337">                return getLocalPart();</span>
            default:
<span class="nc" id="L339">                return &quot;&quot;;</span>

        }
    }

    /**
     * Get the NodeInfo object representing the parent of this node
     */

    public NodeInfo getParent() {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (parent == null) {</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (node instanceof Element) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (((Element) node).isRootElement()) {</span>
<span class="nc" id="L352">                    parent = makeWrapper(((Element) node).getDocument(), getTreeInfo());</span>
                } else {
<span class="nc" id="L354">                    parent = makeWrapper(((Element) node).getParent(), getTreeInfo());</span>
                }
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">            } else if (node instanceof Text) {</span>
<span class="nc" id="L357">                parent = makeWrapper(((Text) node).getParent(), getTreeInfo());</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            } else if (node instanceof Comment) {</span>
<span class="nc" id="L359">                parent = makeWrapper(((Comment) node).getParent(), getTreeInfo());</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            } else if (node instanceof ProcessingInstruction) {</span>
<span class="nc" id="L361">                parent = makeWrapper(((ProcessingInstruction) node).getParent(), getTreeInfo());</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            } else if (node instanceof Attribute) {</span>
<span class="nc" id="L363">                parent = makeWrapper(((Attribute) node).getParent(), getTreeInfo());</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            } else if (node instanceof Document) {</span>
<span class="fc" id="L365">                parent = null;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            } else if (node instanceof Namespace) {</span>
<span class="nc" id="L367">                throw new UnsupportedOperationException(&quot;Cannot find parent of JDOM namespace node&quot;);</span>
            } else {
<span class="nc" id="L369">                throw new IllegalStateException(&quot;Unknown JDOM node type &quot; + node.getClass());</span>
            }
        }
<span class="fc" id="L372">        return parent;</span>
    }

    /**
     * Get the index position of this node among its siblings (starting from 0)
     * In the case of a text node that maps to several adjacent siblings in the JDOM,
     * the numbering actually refers to the position of the underlying JDOM nodes;
     * thus the sibling position for the text node is that of the first JDOM node
     * to which it relates, and the numbering of subsequent XPath nodes is not necessarily
     * consecutive.
     */

    public int getSiblingPosition() {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L386">            int ix = 0;</span>
<span class="nc" id="L387">            getParent();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (parent == null) {</span>
<span class="nc" id="L389">                return 0;</span>
            }
            AxisIterator iter;
<span class="nc bnc" id="L392" title="All 4 branches missed.">            switch (nodeKind) {</span>
                case Type.ELEMENT:
                case Type.TEXT:
                case Type.COMMENT:
                case Type.PROCESSING_INSTRUCTION:
<span class="nc" id="L397">                    iter = parent.iterateAxis(AxisInfo.CHILD);</span>
<span class="nc" id="L398">                    break;</span>
                case Type.ATTRIBUTE:
<span class="nc" id="L400">                    iter = parent.iterateAxis(AxisInfo.ATTRIBUTE);</span>
<span class="nc" id="L401">                    break;</span>
                case Type.NAMESPACE:
<span class="nc" id="L403">                    iter = parent.iterateAxis(AxisInfo.NAMESPACE);</span>
<span class="nc" id="L404">                    break;</span>
                default:
<span class="nc" id="L406">                    index = 0;</span>
<span class="nc" id="L407">                    return index;</span>
            }
            while (true) {
<span class="nc" id="L410">                NodeInfo n = iter.next();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                if (n == null) {</span>
<span class="nc" id="L412">                    break;</span>
                }
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (n.isSameNodeInfo(this)) {</span>
<span class="nc" id="L415">                    index = ix;</span>
<span class="nc" id="L416">                    return index;</span>
                }
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if (((JDOM2NodeWrapper) n).node instanceof List) {</span>
<span class="nc" id="L419">                    ix += ((List) ((JDOM2NodeWrapper) n).node).size();</span>
                } else {
<span class="nc" id="L421">                    ix++;</span>
                }
<span class="nc" id="L423">            }</span>
<span class="nc" id="L424">            throw new IllegalStateException(&quot;JDOM node not linked to parent node&quot;);</span>
        }
<span class="nc" id="L426">        return index;</span>
    }

    @Override
    protected AxisIterator iterateAttributes(NodeTest nodeTest) {
<span class="fc" id="L431">        AxisIterator base = new AttributeEnumeration(this);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if (nodeTest == AnyNodeTest.getInstance()) {</span>
<span class="nc" id="L433">            return base;</span>
        } else {
<span class="fc" id="L435">            return new Navigator.AxisFilter(base, nodeTest);</span>
        }
    }

    @Override
    protected AxisIterator iterateChildren(NodeTest nodeTest) {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (hasChildNodes()) {</span>
<span class="fc" id="L442">            AxisIterator base = new ChildEnumeration(this, true, true);</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">            if (nodeTest == AnyNodeTest.getInstance()) {</span>
<span class="nc" id="L444">                return base;</span>
            } else {
<span class="fc" id="L446">                return new Navigator.AxisFilter(base, nodeTest);</span>
            }
        } else {
<span class="nc" id="L449">            return EmptyIterator.OfNodes.THE_INSTANCE;</span>
        }
    }

    @Override
    protected AxisIterator iterateSiblings(NodeTest nodeTest, boolean forwards) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (nodeTest == AnyNodeTest.getInstance()) {</span>
<span class="nc" id="L456">            return new ChildEnumeration(this, false, forwards);</span>
        } else {
<span class="nc" id="L458">            return new Navigator.AxisFilter(</span>
                    new ChildEnumeration(this, false, forwards),
                    nodeTest);
        }
    }

    @Override
    protected AxisIterator iterateDescendants(NodeTest nodeTest, boolean includeSelf) {
        Iterator&lt;? extends Content&gt; descendants;
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (nodeTest.getUType() == UType.ELEMENT) {</span>
            // only select element nodes
<span class="fc" id="L469">            descendants = ((Parent) node).getDescendants(new ElementFilter());</span>
        } else {
<span class="nc" id="L471">            descendants = ((Parent) node).getDescendants();</span>
        }
<span class="fc" id="L473">        NodeWrappingFunction wrappingFunct = new NodeWrappingFunction&lt;Content, NodeInfo&gt;() {</span>
            public NodeInfo wrap(Content node) {
<span class="fc" id="L475">                return makeWrapper(node, getTreeInfo());</span>
            }
        };
<span class="fc" id="L478">        AxisIterator wrappedDescendants = new DescendantWrappingIterator(descendants, wrappingFunct);</span>

<span class="pc bpc" id="L480" title="1 of 4 branches missed.">        if (includeSelf &amp;&amp; nodeTest.matchesNode(this)) {</span>
<span class="nc" id="L481">            wrappedDescendants = new PrependIterator(this, wrappedDescendants);</span>
        }

<span class="pc bpc" id="L484" title="2 of 6 branches missed.">        if (nodeTest instanceof AnyNodeTest || (nodeTest instanceof NodeKindTest &amp;&amp; ((NodeKindTest) nodeTest).getNodeKind() == Type.ELEMENT)) {</span>
<span class="fc" id="L485">            return wrappedDescendants;</span>
        } else {
<span class="fc" id="L487">            return new Navigator.AxisFilter(wrappedDescendants, nodeTest);</span>
        }
    }

    private static class DescendantWrappingIterator extends NodeWrappingAxisIterator&lt;Object&gt; {

        public DescendantWrappingIterator(Iterator descendantIterator, NodeWrappingFunction&lt;Object, NodeInfo&gt; wrappingFunction) {
<span class="fc" id="L494">            super(descendantIterator, wrappingFunction);</span>
<span class="fc" id="L495">        }</span>

        public DescendantWrappingIterator getAnother() {
<span class="nc" id="L498">            return new DescendantWrappingIterator(getBaseIterator(), getNodeWrappingFunction());</span>
        }

        @Override
        public boolean isIgnorable(Object node) {
<span class="fc" id="L503">            return node instanceof DocType;</span>
        }
    }

    /**
     * Get the string value of a given attribute of this node
     *
     * @param uri   the namespace URI of the attribute name. Supply the empty string for an attribute
     *              that is in no namespace
     * @param local the local part of the attribute name.
     * @return the attribute value if it exists, or null if it does not exist. Always returns null
     *         if this node is not an element.
     * @since 8.4
     */


    public String getAttributeValue(String uri, String local) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (nodeKind == Type.ELEMENT) {</span>
<span class="nc" id="L521">            return ((Element) node).getAttributeValue(local,</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    (uri.equals(NamespaceConstant.XML) ?</span>
                            Namespace.XML_NAMESPACE :
<span class="nc" id="L524">                            Namespace.getNamespace(uri)));</span>
            // JDOM doesn't allow getNamespace() on the XML namespace URI
        }
<span class="nc" id="L527">        return null;</span>
    }

    /**
     * Get the root node - always a document node with this tree implementation
     *
     * @return the NodeInfo representing the containing document
     */

    public NodeInfo getRoot() {
<span class="fc" id="L537">        return treeInfo.getRootNode();</span>
    }

    /**
     * Determine whether the node has any children. &lt;br /&gt;
     * Note: the result is equivalent to &lt;br /&gt;
     * getEnumeration(AxisInfo.CHILD, AnyNodeTest.getInstance()).hasNext()
     */

    public boolean hasChildNodes() {
<span class="pc bpc" id="L547" title="1 of 3 branches missed.">        switch (nodeKind) {</span>
            case Type.DOCUMENT:
<span class="fc" id="L549">                return true;</span>
            case Type.ELEMENT:
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                return !((Element) node).getContent().isEmpty();</span>
            default:
<span class="nc" id="L553">                return false;</span>
        }
    }

    /**
     * Get a character string that uniquely identifies this node.
     * Note: a.isSameNode(b) if and only if generateId(a)==generateId(b)
     *
     * @param buffer a Buffer to contain a string that uniquely identifies this node, across all
     *               documents
     */

    public void generateId(FastStringBuffer buffer) {
<span class="nc" id="L566">        Navigator.appendSequentialKey(this, buffer, true);</span>
        //buffer.append(Navigator.getSequentialKey(this));
<span class="nc" id="L568">    }</span>

    /**
     * Copy this node to a given outputter (deep copy)
     */

    public void copy(Receiver out, int copyOptions, Location locationId) throws XPathException {
<span class="nc" id="L575">        Navigator.copy(this, out, copyOptions, locationId);</span>
<span class="nc" id="L576">    }</span>

    /**
     * Get all namespace undeclarations and undeclarations defined on this element.
     *
     * @param buffer If this is non-null, and the result array fits in this buffer, then the result
     *               may overwrite the contents of this array, to avoid the cost of allocating a new array on the heap.
     * @return An array of integers representing the namespace declarations and undeclarations present on
     *         this element. For a node other than an element, return null. Otherwise, the returned array is a
     *         sequence of namespace codes, whose meaning may be interpreted by reference to the name pool. The
     *         top half word of each namespace code represents the prefix, the bottom half represents the URI.
     *         If the bottom half is zero, then this is a namespace undeclaration rather than a declaration.
     *         The XML namespace is never included in the list. If the supplied array is larger than required,
     *         then the first unused entry will be set to -1.
     *         &lt;p/&gt;
     *         &lt;p&gt;For a node other than an element, the method returns null.&lt;/p&gt;
     */

    public NamespaceBinding[] getDeclaredNamespaces(NamespaceBinding[] buffer) {
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (node instanceof Element) {</span>
<span class="nc" id="L596">            Element elem = (Element) node;</span>
<span class="nc" id="L597">            List addl = elem.getAdditionalNamespaces();</span>
<span class="nc" id="L598">            int size = addl.size() + 1;</span>
<span class="nc bnc" id="L599" title="All 4 branches missed.">            NamespaceBinding[] result = (buffer == null || size &gt; buffer.length ? new NamespaceBinding[size] : buffer);</span>
<span class="nc" id="L600">            NamePool pool = getNamePool();</span>
<span class="nc" id="L601">            Namespace ns = elem.getNamespace();</span>
<span class="nc" id="L602">            String prefix = ns.getPrefix();</span>
<span class="nc" id="L603">            String uri = ns.getURI();</span>
<span class="nc" id="L604">            result[0] = new NamespaceBinding(prefix, uri);</span>
<span class="nc" id="L605">            int i = 1;</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (!addl.isEmpty()) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                for (Object anAddl : addl) {</span>
<span class="nc" id="L608">                    ns = (Namespace) anAddl;</span>
<span class="nc" id="L609">                    result[i++] = new NamespaceBinding(ns.getPrefix(), ns.getURI());</span>
<span class="nc" id="L610">                }</span>
            }
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (size &lt; result.length) {</span>
<span class="nc" id="L613">                result[size] = null;</span>
            }
<span class="nc" id="L615">            return result;</span>
        } else {
<span class="nc" id="L617">            return null;</span>
        }
    }

    /**
     * Determine whether this node has the is-id property
     *
     * @return true if the node is an ID
     */

    public boolean isId() {
<span class="nc bnc" id="L628" title="All 4 branches missed.">        return node instanceof Attribute &amp;&amp; ((Attribute) node).getAttributeType() == Attribute.ID_TYPE;</span>
    }

    /**
     * Determine whether this node has the is-idref property
     *
     * @return true if the node is an IDREF or IDREFS element or attribute
     */

    public boolean isIdref() {
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (node instanceof Attribute) {</span>
<span class="nc" id="L639">            AttributeType type = ((Attribute) node).getAttributeType();</span>
<span class="nc bnc" id="L640" title="All 4 branches missed.">            return type == Attribute.IDREF_TYPE || type == Attribute.IDREFS_TYPE;</span>
        } else {
<span class="nc" id="L642">            return false;</span>
        }
    }


    ///////////////////////////////////////////////////////////////////////////////
    // Axis enumeration classes
    ///////////////////////////////////////////////////////////////////////////////


    private final class AttributeEnumeration extends AxisIteratorImpl {

        private Iterator atts;
<span class="fc" id="L655">        private int ix = 0;</span>
        private JDOM2NodeWrapper start;

<span class="fc" id="L658">        public AttributeEnumeration(JDOM2NodeWrapper start) {</span>
<span class="fc" id="L659">            this.start = start;</span>
<span class="fc" id="L660">            atts = ((Element) start.node).getAttributes().iterator();</span>
<span class="fc" id="L661">        }</span>

        public NodeInfo next() {
<span class="fc bfc" id="L664" title="All 2 branches covered.">            if (atts.hasNext()) {</span>
<span class="fc" id="L665">                return makeWrapper(atts.next(), getTreeInfo(), start, ix++);</span>
            } else {
<span class="fc" id="L667">                return null;</span>
            }
        }

        public AxisIterator getAnother() {
<span class="nc" id="L672">            return new AttributeEnumeration(start);</span>
        }

    }  // end of class AttributeEnumeration


    /**
     * The class ChildEnumeration handles not only the child axis, but also the
     * following-sibling and preceding-sibling axes. It can also iterate the children
     * of the start node in reverse order, something that is needed to support the
     * preceding and preceding-or-ancestor axes (the latter being used by xsl:number)
     */

    private final class ChildEnumeration extends AxisIteratorImpl {

        private JDOM2NodeWrapper start;
        private JDOM2NodeWrapper commonParent;
        private ListIterator children;
<span class="fc" id="L690">        private int ix = 0;</span>
        private boolean downwards;  // iterate children of start node (not siblings)
        private boolean forwards;   // iterate in document order (not reverse order)

        public ChildEnumeration(JDOM2NodeWrapper start,
<span class="fc" id="L695">                                boolean downwards, boolean forwards) {</span>
<span class="fc" id="L696">            this.start = start;</span>
<span class="fc" id="L697">            this.downwards = downwards;</span>
<span class="fc" id="L698">            this.forwards = forwards;</span>

<span class="pc bpc" id="L700" title="1 of 2 branches missed.">            if (downwards) {</span>
<span class="fc" id="L701">                commonParent = start;</span>
            } else {
<span class="nc" id="L703">                commonParent = (JDOM2NodeWrapper) start.getParent();</span>
            }

<span class="fc bfc" id="L706" title="All 2 branches covered.">            if (commonParent.getNodeKind() == Type.DOCUMENT) {</span>
<span class="fc" id="L707">                children = ((Document) commonParent.node).getContent().listIterator();</span>
            } else {
<span class="fc" id="L709">                children = ((Element) commonParent.node).getContent().listIterator();</span>
            }

<span class="pc bpc" id="L712" title="1 of 2 branches missed.">            if (downwards) {</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">                if (!forwards) {</span>
                    // backwards enumeration: go to the end
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    while (children.hasNext()) {</span>
<span class="nc" id="L716">                        children.next();</span>
<span class="nc" id="L717">                        ix++;</span>
                    }
                }
            } else {
<span class="nc" id="L721">                ix = start.getSiblingPosition();</span>
                // find the start node among the list of siblings
<span class="nc" id="L723">                Object n = null;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (forwards) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    for (int i = 0; i &lt;= ix; i++) {</span>
<span class="nc" id="L726">                        n = children.next();</span>
                    }
<span class="nc bnc" id="L728" title="All 2 branches missed.">                    if (n instanceof Text) {</span>
                        // move to the last of a sequence of adjacent text nodes
<span class="nc" id="L730">                        boolean atEnd = false;</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                        while (n instanceof Text) {</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                            if (children.hasNext()) {</span>
<span class="nc" id="L733">                                n = children.next();</span>
<span class="nc" id="L734">                                ix++;</span>
                            } else {
<span class="nc" id="L736">                                atEnd = true;</span>
<span class="nc" id="L737">                                break;</span>
                            }
                        }
<span class="nc bnc" id="L740" title="All 2 branches missed.">                        if (!atEnd) {</span>
<span class="nc" id="L741">                            children.previous();</span>
                        }
<span class="nc" id="L743">                    } else {</span>
<span class="nc" id="L744">                        ix++;</span>
                    }
                } else {
<span class="nc bnc" id="L747" title="All 2 branches missed.">                    for (int i = 0; i &lt; ix; i++) {</span>
<span class="nc" id="L748">                        children.next();</span>
                    }
<span class="nc" id="L750">                    ix--;</span>
                }
            }
<span class="fc" id="L753">        }</span>

        public NodeInfo next() {
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">            if (forwards) {</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">                if (children.hasNext()) {</span>
<span class="fc" id="L758">                    Object nextChild = children.next();</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                    if (nextChild instanceof DocType) {</span>
<span class="nc" id="L760">                        return next();</span>
                    }
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">                    if (nextChild instanceof EntityRef) {</span>
<span class="nc" id="L763">                        throw new IllegalStateException(&quot;Unexpanded entity in JDOM tree&quot;);</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                    } else if (nextChild instanceof Text) {</span>
<span class="fc" id="L765">                        JDOM2NodeWrapper current = makeWrapper(nextChild, getTreeInfo(), commonParent, ix++);</span>
<span class="fc" id="L766">                        List&lt;Object&gt; list = null;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                        while (children.hasNext()) {</span>
<span class="fc" id="L768">                            Object n = children.next();</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">                            if (n instanceof Text) {</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                                if (list == null) {</span>
<span class="nc" id="L771">                                    list = new ArrayList&lt;Object&gt;(4);</span>
<span class="nc" id="L772">                                    list.add(current.node);</span>
                                }
<span class="nc" id="L774">                                list.add(n);</span>
<span class="nc" id="L775">                                ix++;</span>
                            } else {
                                // we've looked ahead too far
<span class="fc" id="L778">                                children.previous();</span>
<span class="fc" id="L779">                                break;</span>
                            }
<span class="nc" id="L781">                        }</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">                        if (list != null) {</span>
<span class="nc" id="L783">                            current.node = list;</span>
                        }
<span class="fc" id="L785">                        return current;</span>
                    } else {
<span class="fc" id="L787">                        return makeWrapper(nextChild, getTreeInfo(), commonParent, ix++);</span>
                    }
                } else {
<span class="nc" id="L790">                    return null;</span>
                }
            } else {    // backwards
<span class="nc bnc" id="L793" title="All 2 branches missed.">                if (children.hasPrevious()) {</span>
<span class="nc" id="L794">                    Object nextChild = children.previous();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                    if (nextChild instanceof DocType) {</span>
<span class="nc" id="L796">                        return next();</span>
                    }
<span class="nc bnc" id="L798" title="All 2 branches missed.">                    if (nextChild instanceof EntityRef) {</span>
<span class="nc" id="L799">                        throw new IllegalStateException(&quot;Unexpanded entity in JDOM tree&quot;);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                    } else if (nextChild instanceof Text) {</span>
<span class="nc" id="L801">                        JDOM2NodeWrapper current = makeWrapper(nextChild, getTreeInfo(), commonParent, ix--);</span>
<span class="nc" id="L802">                        List&lt;Object&gt; list = null;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">                        while (children.hasPrevious()) {</span>
<span class="nc" id="L804">                            Object n = children.previous();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                            if (n instanceof Text) {</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                                if (list == null) {</span>
<span class="nc" id="L807">                                    list = new ArrayList&lt;Object&gt;(4);</span>
<span class="nc" id="L808">                                    list.add(current.node);</span>
                                }
<span class="nc" id="L810">                                list.add(0, n);</span>
<span class="nc" id="L811">                                ix--;</span>
                            } else {
                                // we've looked ahead too far
<span class="nc" id="L814">                                children.next();</span>
<span class="nc" id="L815">                                break;</span>
                            }
<span class="nc" id="L817">                        }</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                        if (list != null) {</span>
<span class="nc" id="L819">                            current.node = list;</span>
                        }
<span class="nc" id="L821">                        return current;</span>
                    } else {
<span class="nc" id="L823">                        return makeWrapper(nextChild, getTreeInfo(), commonParent, ix--);</span>
                    }
                } else {
<span class="nc" id="L826">                    return null;</span>
                }
            }
        }


        public AxisIterator getAnother() {
<span class="nc" id="L833">            return new ChildEnumeration(start, downwards, forwards);</span>
        }

    } // end of class ChildEnumeration

}


// Original Code is Copyright (c) 2009 Saxonica Limited. All rights reserved.
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>