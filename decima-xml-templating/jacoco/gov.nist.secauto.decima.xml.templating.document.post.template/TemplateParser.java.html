<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TemplateParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Decima Framework XML Templating</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.decima.xml.templating.document.post.template</a> &gt; <span class="el_source">TemplateParser.java</span></div><h1>TemplateParser.java</h1><pre class="source lang-java linenums">/**
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */

package gov.nist.secauto.decima.xml.templating.document.post.template;

import gov.nist.secauto.decima.xml.document.XMLDocument;
import gov.nist.secauto.decima.xml.jdom2.JDOMUtil;
import gov.nist.secauto.decima.xml.jdom2.saxon.xpath.SaxonXPathFactory;

import org.jdom2.Attribute;
import org.jdom2.Content;
import org.jdom2.DataConversionException;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.filter.Filter;
import org.jdom2.filter.Filters;
import org.jdom2.input.sax.SAXEngine;
import org.jdom2.xpath.XPathFactory;
import org.xml.sax.SAXException;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class TemplateParser {
<span class="fc" id="L59">  public static final Namespace TEMPLATE_NAMESPACE</span>
<span class="fc" id="L60">      = Namespace.getNamespace(&quot;http://csrc.nist.gov/ns/decima/template/1.0&quot;);</span>
  public static final String TEMPLATE_LOCAL_NAME = &quot;template&quot;;

<span class="fc" id="L63">  private static final TemplateParser instance = new TemplateParser();</span>

  public static TemplateParser getInstance() {
<span class="fc" id="L66">    return instance;</span>
  }

<span class="fc" id="L69">  private final XPathFactory xpathfactory = new SaxonXPathFactory();</span>

<span class="fc" id="L71">  private TemplateParser() {</span>
    // prevent construction
<span class="fc" id="L73">  }</span>

  protected XPathFactory getXpathfactory() {
<span class="fc" id="L76">    return xpathfactory;</span>
  }

  public TemplateProcessor parse(XMLDocument template) throws TemplateParserException {
<span class="nc" id="L80">    return parse(template.getJDOMDocument().getRootElement(), template.getOriginalLocation());</span>
  }

  /**
   * Parse an XML element as a Decima template.
   * 
   * @param templateElement
   *          the element to parse
   * @param contextSystemId
   *          the systemId of the containing document
   * @return a new template processor based on the element's contents
   * @throws TemplateParserException
   *           if an error occurred while parsing the element's contents
   */
  public TemplateProcessor parse(Element templateElement, URL contextSystemId) throws TemplateParserException {
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">    if (!TEMPLATE_NAMESPACE.equals(templateElement.getNamespace())</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        || !TEMPLATE_LOCAL_NAME.equals(templateElement.getName())) {</span>
<span class="nc" id="L97">      throw new TemplateParserException(</span>
          &quot;The provided element argument is not a template element {&quot; + TEMPLATE_NAMESPACE + &quot;}&quot; + TEMPLATE_LOCAL_NAME
<span class="nc" id="L99">              + &quot; The namespace found was: {&quot; + templateElement.getNamespaceURI() + &quot;}&quot; + templateElement.getName());</span>
    }
<span class="fc" id="L101">    return buildTemplate(templateElement, contextSystemId).build();</span>
  }

  /**
   * Parse an XML document as a Decima template.
   * 
   * @param is
   *          the stream to read the document from
   * @param contextSystemId
   *          the systemId of the document being read
   * @return a new template processor based on the XML contents
   * @throws TemplateParserException
   *           if an error occurred while parsing the XML contents
   */
  public TemplateProcessor parse(InputStream is, URL contextSystemId) throws TemplateParserException {
    SAXEngine saxEngine;
    try {
<span class="fc" id="L118">      saxEngine = JDOMUtil.newValidatingSAXEngine(new URL(&quot;classpath:schema/decima/decima-template-1.0.xsd&quot;));</span>
<span class="nc" id="L119">    } catch (MalformedURLException | SAXException | JDOMException e) {</span>
<span class="nc" id="L120">      throw new TemplateParserException(e);</span>
<span class="fc" id="L121">    }</span>
    Document document;
    try {
<span class="fc" id="L124">      document = saxEngine.build(is);</span>
<span class="nc" id="L125">    } catch (IOException | JDOMException e) {</span>
<span class="nc" id="L126">      throw new TemplateParserException(&quot;unable to load template document&quot;, e);</span>
<span class="fc" id="L127">    }</span>
<span class="fc" id="L128">    return parse(document.getRootElement(), contextSystemId);</span>
  }
  //
  // public TemplateProcessor parse(TemplateDocument.Template template, Document dependency) throws
  // ParserException {
  // TemplateProcessorBuilder builder = buildTemplate(template);
  // builder.setTemplate(dependency);
  // return builder.build();
  // }

  protected TemplateProcessorBuilder buildTemplate(Element templateElement, URL contextSystemId)
      throws TemplateParserException {
<span class="fc" id="L140">    Objects.requireNonNull(templateElement);</span>
<span class="fc" id="L141">    TemplateProcessorBuilder builder = new TemplateProcessorBuilder();</span>
<span class="fc" id="L142">    builder.setContextSystemId(contextSystemId);</span>
<span class="fc" id="L143">    String templatePath = templateElement.getAttributeValue(&quot;template&quot;);</span>
    try {
<span class="fc" id="L145">      URI templateURI = URI.create(templatePath);</span>
      // if (!templateURI.isAbsolute() &amp;&amp; !templateURI.getPath().startsWith(&quot;./&quot;)) {
      // try {
      // templateURI = new URI(templateURI.getScheme(), templateURI.getUserInfo(),
      // templateURI.getHost(), templateURI.getPort(), &quot;./&quot;+templateURI.getPath(),
      // templateURI.getQuery(), templateURI.getFragment());
      // } catch (URISyntaxException e) {
      // throw new ParserException(e);
      // }
      // }
      // TODO: Why not just call contextSystemId.toURI()?
<span class="fc" id="L156">      URI base = URI.create(contextSystemId.toString());</span>
      URL templateURL;
      // TODO: this is a hack because classpath URLs do not have a / starting with the schema
      // specific part.
<span class="pc bpc" id="L160" title="3 of 4 branches missed.">      if (base.isOpaque() &amp;&amp; base.getScheme().equals(&quot;classpath&quot;)) {</span>
<span class="nc" id="L161">        templateURL = new URL(contextSystemId, templatePath);</span>
      } else {
<span class="fc" id="L163">        templateURL = base.resolve(templateURI).toURL();</span>
      }
<span class="fc" id="L165">      builder.setTemplateURL(templateURL);</span>
<span class="nc" id="L166">    } catch (MalformedURLException e) {</span>
<span class="nc" id="L167">      throw new TemplateParserException(e);</span>
<span class="fc" id="L168">    }</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">    for (Element actionElement : templateElement.getChildren()) {</span>
<span class="fc" id="L171">      String localName = actionElement.getName();</span>
<span class="pc bpc" id="L172" title="1 of 7 branches missed.">      switch (localName) {</span>
      case &quot;add-attribute&quot;:
<span class="fc" id="L174">        buildAddAction(builder, actionElement);</span>
<span class="fc" id="L175">        break;</span>
      case &quot;delete&quot;:
<span class="fc" id="L177">        buildDeleteAction(builder, actionElement);</span>
<span class="fc" id="L178">        break;</span>
      case &quot;insert-child&quot;:
<span class="fc" id="L180">        buildInsertChildAction(builder, actionElement);</span>
<span class="fc" id="L181">        break;</span>
      case &quot;insert-sibling&quot;:
<span class="fc" id="L183">        buildInsertSiblingAction(builder, actionElement);</span>
<span class="fc" id="L184">        break;</span>
      case &quot;modify-attribute&quot;:
<span class="fc" id="L186">        buildModifyAttributeAction(builder, actionElement);</span>
<span class="fc" id="L187">        break;</span>
      case &quot;replace&quot;:
<span class="fc" id="L189">        buildReplaceAction(builder, actionElement);</span>
<span class="fc" id="L190">        break;</span>
      default:
<span class="nc" id="L192">        throw new TemplateParserException(</span>
<span class="nc" id="L193">            &quot;Invalid action type:  {&quot; + actionElement.getNamespaceURI() + &quot;}&quot; + actionElement.getName());</span>
      }
<span class="fc" id="L195">    }</span>
<span class="fc" id="L196">    return builder;</span>
  }

  private Map&lt;String, String&gt; getNamespacePrefixes(Element element) {
<span class="fc" id="L200">    Map&lt;String, String&gt; retval = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    for (Namespace ns : element.getNamespacesInScope()) {</span>
<span class="fc" id="L202">      retval.put(ns.getPrefix(), ns.getURI());</span>
<span class="fc" id="L203">    }</span>
<span class="fc" id="L204">    retval.put(Namespace.XML_NAMESPACE.getPrefix(), Namespace.XML_NAMESPACE.getURI());</span>
<span class="fc" id="L205">    return retval;</span>
  }

  private &lt;T extends Content&gt; List&lt;T&gt; getContentNodes(Element element, Filter&lt;T&gt; filter)
      throws TemplateParserException {
<span class="fc" id="L210">    List&lt;T&gt; children = element.getContent(filter);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">    if (children.isEmpty()) {</span>
<span class="nc" id="L212">      throw new TemplateParserException(&quot;action does not contain content nodes&quot;);</span>
    }
<span class="fc" id="L214">    List&lt;T&gt; retval = new ArrayList&lt;&gt;(children);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    for (T child : retval) {</span>
<span class="fc" id="L216">      child.detach();</span>
<span class="fc" id="L217">    }</span>
<span class="fc" id="L218">    return Collections.unmodifiableList(retval);</span>
  }

  protected void buildModifyAttributeAction(TemplateProcessorBuilder builder, Element actionElement) {
<span class="fc" id="L222">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L223">    builder.addAction(new ModifyAttributeAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;),</span>
<span class="fc" id="L224">        prefixToNamespaceMap, actionElement.getAttributeValue(&quot;value&quot;)));</span>
<span class="fc" id="L225">  }</span>

  protected void buildInsertSiblingAction(TemplateProcessorBuilder builder, Element actionElement)
      throws TemplateParserException {
<span class="fc" id="L229">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L230">    builder.addAction(new InsertSiblingAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;),</span>
<span class="fc" id="L231">        prefixToNamespaceMap, getContentNodes(actionElement, Filters.element()),</span>
<span class="fc" id="L232">        Boolean.valueOf(actionElement.getAttributeValue(&quot;before&quot;))));</span>
<span class="fc" id="L233">  }</span>

  protected void buildInsertChildAction(TemplateProcessorBuilder builder, Element actionElement)
      throws TemplateParserException {
<span class="fc" id="L237">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L238">    Integer index = null;</span>
    try {
<span class="fc" id="L240">      Attribute indexAttr = actionElement.getAttribute(&quot;index&quot;);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (indexAttr != null) {</span>
<span class="fc" id="L242">        index = indexAttr.getIntValue();</span>
      }
<span class="nc" id="L244">    } catch (DataConversionException e) {</span>
<span class="nc" id="L245">      throw new TemplateParserException(e);</span>
<span class="fc" id="L246">    }</span>
<span class="fc" id="L247">    builder.addAction(new InsertChildAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;),</span>
<span class="fc" id="L248">        prefixToNamespaceMap, getContentNodes(actionElement, Filters.element()), index));</span>
<span class="fc" id="L249">  }</span>

  protected void buildDeleteAction(TemplateProcessorBuilder builder, Element actionElement) {
<span class="fc" id="L252">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L253">    builder</span>
<span class="fc" id="L254">        .addAction(new DeleteAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;), prefixToNamespaceMap));</span>
<span class="fc" id="L255">  }</span>

  protected void buildAddAction(TemplateProcessorBuilder builder, Element actionElement) {
<span class="fc" id="L258">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L259">    builder.addAction(new AddAttributeAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;),</span>
<span class="fc" id="L260">        prefixToNamespaceMap, actionElement.getAttributeValue(&quot;ns&quot;), actionElement.getAttributeValue(&quot;name&quot;),</span>
<span class="fc" id="L261">        actionElement.getAttributeValue(&quot;value&quot;)));</span>
<span class="fc" id="L262">  }</span>

  protected void buildReplaceAction(TemplateProcessorBuilder builder, Element actionElement)
      throws TemplateParserException {
<span class="fc" id="L266">    Map&lt;String, String&gt; prefixToNamespaceMap = getNamespacePrefixes(actionElement);</span>
<span class="fc" id="L267">    builder.addAction(new ReplaceAction(getXpathfactory(), actionElement.getAttributeValue(&quot;xpath&quot;),</span>
<span class="fc" id="L268">        prefixToNamespaceMap, getContentNodes(actionElement, Filters.element())));</span>
<span class="fc" id="L269">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>